// Package pktmgr handles a collection of messages from a single incident (i.e.,
// a single ICS-309 form).
package pktmgr

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/rothskeller/packet/pktmsg"
	"github.com/rothskeller/packet/typedmsg"
	"github.com/rothskeller/packet/xscmsg"
	"github.com/rothskeller/packet/xscmsg/delivrcpt"
	"github.com/rothskeller/packet/xscmsg/readrcpt"
)

// maxMessageSize is the largest supported message.  Files larger than this are
// not read even if they have a name that looks like a message ID.
const maxMessageSize = 65536

// msgfileRE is the regular expression that a filename must match in order to be
// read as a message.  It matches a local message ID followed by ".txt",
// ".DR.txt" (for delivery receipts), or ".RR.txt" (for read receipts).  The
// local message ID must be three letters or digits with at least one letter,
// followed by a dash, a positive integer, and a suffix "P" or "M".
//
// Some senders might send us messages with IDs that are slightly out of spec.
// However, the message files are always named with the local message ID,
// presumed to have been generated by this program, so we can rely on its strict
// definition of message ID syntax.
var msgfileRE = regexp.MustCompile(`^(((?:[0-9][A-Z]{2}|[A-Z][A-Z0-9]{2})-)([0-9]*[1-9][0-9]*)([PM]))(?:\.([DR]R))?\.txt$`)

// An Incident represents a single incident and its related messages.  Each
// Incident is stored in a distinct directory in the file system, and
// corresponds to a single ICS-309 form.
type Incident struct {
	config     Config
	nextMsgNum int
	list       []*Message
	index      map[string]*Message
}

// NewIncident creates a new Incident with the specified configuration, using
// the current working directory for message storage.
func NewIncident(config Config) (i *Incident, err error) {
	i = new(Incident)
	i.config = config
	i.config.fillin()
	if err = i.Refresh(); err != nil {
		return nil, err
	}
	return i, nil
}

// Refresh re-loads all incident messages from disk.
func (i *Incident) Refresh() (err error) {
	var (
		dir   *os.File
		files []os.FileInfo
	)
	i.nextMsgNum, i.list, i.index = i.config.startMsgNum, i.list[:0], make(map[string]*Message)
	if dir, err = os.Open("."); err != nil {
		return err
	}
	defer dir.Close()
	if files, err = dir.Readdir(0); err != nil {
		return err
	}
	for _, fi := range files {
		if !fi.Mode().IsRegular() {
			continue
		}
		if fi.Size() > maxMessageSize {
			continue
		}
		if err = i.readMessage(fi.Name()); err != nil {
			return err
		}
	}
	for _, mr := range i.list {
		if mr.M == nil {
			return fmt.Errorf("found receipt for non-existent message %s", mr.LMI)
		}
	}
	// Regenerate in case someone else changed message files.
	if i.config.BackgroundPDF != nil {
		go func() {
			i.config.BackgroundPDF.Lock()
			i.ics309()
			i.config.BackgroundPDF.Unlock()
		}()
	} else {
		i.ics309()
	}
	return nil
}

// readMessage reads the message in the specified file, and adds it into the
// list of messages (replacing any previously existing message with the same
// LMI).
func (i *Incident) readMessage(filename string) (err error) {
	var (
		lmi  string
		rcpt string
		tm   typedmsg.Message
		m    *Message
	)
	if match := msgfileRE.FindStringSubmatch(filename); match != nil {
		lmi, rcpt = match[1], match[5]
		if match[2] == i.config.msgIDPrefix && match[4] == i.config.msgIDSuffix {
			num, _ := strconv.Atoi(match[3])
			if num >= i.nextMsgNum {
				i.nextMsgNum = num + 1
			}
		}
	} else {
		return nil
	}
	if tm, err = readMessage(filename); err != nil {
		return fmt.Errorf("%s: %s", filename, err)
	}
	if m = i.GetLMI(lmi); m == nil {
		m = i.addLMI(lmi)
	}
	switch rcpt {
	case "":
		if tm, ok := tm.(xscmsg.IMessage); ok {
			m.M = tm
			if m.IsReceived() {
				m.RMI = tm.GetOriginMsgID()
			}
		} else {
			return fmt.Errorf("%s does not contain an xscmsg.IMessage", filename)
		}
	case "DR":
		if tm, ok := tm.(*delivrcpt.DeliveryReceipt); ok {
			m.DR = tm
			if !m.IsReceived() {
				m.RMI = tm.LocalMessageID
			}
		} else {
			return fmt.Errorf("%s does not contain a delivery receipt", filename)
		}
	case "RR":
		if tm, ok := tm.(*readrcpt.ReadReceipt); ok {
			m.RR = tm
		} else {
			return fmt.Errorf("%s does not contain a read receipt", filename)
		}
	}
	return nil
}

// Count returns the number of messages in the Incident.
func (i *Incident) Count() int {
	return len(i.list)
}

// GetIndex returns the message at the specified numbered position in the list of
// messages.  It returns nil if no such message exists.
func (i *Incident) GetIndex(idx int) *Message {
	if idx >= 0 && idx < len(i.list) {
		return i.list[idx]
	}
	return nil
}

// GetLMI returns the message with the specified local message ID.  It returns
// nil if no such message exists.
func (i *Incident) GetLMI(lmi string) *Message {
	return i.index[lmi]
}

// AddDraft creates a new draft message of the specified type with the next
// available local message ID, and returns it.  The local message ID, default
// body, and operator fields of the message are filled in.  If replyTo is
// specified, the To: field of the draft is set to the From: field of replyTo,
// the Subject and Body fields of the draft are copied from replyTo, and the
// Reference field of the draft (if any) is set to the OMI of replyTo.
func (i *Incident) AddDraft(tag string, replyTo *Message) (m *Message) {
	if tm, ok := typedmsg.Create(tag).(xscmsg.IMessage); ok {
		lmi := fmt.Sprintf("%s%03d%s", i.config.msgIDPrefix, i.nextMsgNum, i.config.msgIDSuffix)
		m = i.addLMI(lmi)
		i.nextMsgNum++
		m.M = tm
	} else {
		return nil
	}
	if replyTo != nil {
		m.M.SetTo(replyTo.M.GetFrom())
	}
	m.M.SetOperator(false, i.config.OpCall, i.config.OpName)
	m.M.SetTactical(i.config.TacCall, i.config.TacName)
	m.M.SetOriginMsgID(m.LMI)
	m.M.SetBody(i.config.DefBody)
	if replyTo != nil {
		m.M.SetHandling(replyTo.M.GetHandling())
		m.M.SetReference(replyTo.RMI)
		m.M.SetSubject(replyTo.M.GetSubject())
		if rbody := replyTo.M.GetBody(); rbody != "" {
			m.M.SetBody(rbody)
		}
	}
	m.Save()
	return m
}

// Remove removes a message from the Incident.
func (i *Incident) Remove(mr *Message) {
	for j, m := range i.list {
		if m == mr {
			i.list = append(i.list[:j], i.list[j+1:]...)
			break
		}
	}
	delete(i.index, mr.LMI)
	mr.remove()
}

// HasBulletin returns whether the Incident contains a bulletin from the
// specified area with the specified subject prefix.
func (i *Incident) HasBulletin(area, subjectPrefix string) bool {
	for _, m := range i.list {
		if m.M.GetRxArea() == area && strings.HasPrefix(m.M.GetSubjectHeader(), subjectPrefix) {
			return true
		}
	}
	return false
}

// Receive records a newly received message.  Raw is the raw text of the message
// as received from JNOS.  BBS is the name of the BBS from which the message was
// retrieved.  For bulletin messages, bulletin is the area to which the bulletin
// was sent; for all other messages, bulletin is an empty string.  When a
// delivery receipt should be sent for the message, it is queued to be sent and
// also returned by this function.
func (i *Incident) Receive(raw, bbs, bulletin string) (dr *delivrcpt.DeliveryReceipt, err error) {
	var (
		pm *pktmsg.Message
		m  *Message
	)
	if pm, err = pktmsg.ReceiveMessage(raw, bbs, bulletin); err != nil {
		return nil, err
	}
	switch tm := typedmsg.Recognize(pm).(type) {
	case *delivrcpt.DeliveryReceipt:
		m = i.findWithSubject(tm.DeliveredSubject)
		if m == nil {
			return nil, errors.New("dropping received delivery receipt: no matching subject")
		}
		if !m.IsSent() {
			return nil, errors.New("dropping received delivery receipt: matching message was received not sent")
		}
		if m.DR != nil {
			return nil, errors.New("dropping received delivery receipt: already have one")
		}
		m.DR = tm
		m.RMI = tm.LocalMessageID
	case *readrcpt.ReadReceipt:
		m = i.findWithSubject(tm.ReadSubject)
		if m == nil {
			return nil, errors.New("dropping received read receipt: no matching subject")
		}
		if !m.IsSent() {
			return nil, errors.New("dropping received read receipt: matching message was received not sent")
		}
		if m.RR != nil {
			return nil, errors.New("dropping received read receipt: already have one")
		}
		m.RR = tm
	case xscmsg.IMessage:
		lmi := fmt.Sprintf("%s%03d%s", i.config.msgIDPrefix, i.nextMsgNum, i.config.msgIDSuffix)
		m = i.addLMI(lmi)
		i.nextMsgNum++
		m.Unread = true
		m.M = tm
		m.RMI = tm.GetOriginMsgID()
		m.M.SetDestinationMsgID(lmi)
		m.M.SetOperator(true, i.config.OpCall, i.config.OpName)
		if bulletin == "" {
			m.DR = delivrcpt.NewDeliveryReceipt()
			m.DR.DeliveredTo = tm.GetTo()
			m.DR.DeliveredSubject = tm.GetSubjectHeader()
			m.DR.DeliveredTime = tm.GetRxDateTime().Format("01/02/2006 15:04")
			m.DR.LocalMessageID = lmi
			m.DR.SetTo(tm.GetFrom())
			i.markReady(m.DR)
			m.DR.Save() // force encode
			dr = m.DR
		}
	default:
		return nil, errors.New("dropping message that is neither a receipt nor an xscmsg.Message")
	}
	return dr, m.Save()
}

// findWithSubject returns the message with the specified subject line.  It
// returns nil if no such message exists.  (This is used for matching delivery
// and read receipts against their primary messages.)
func (i *Incident) findWithSubject(subject string) *Message {
	for j := len(i.list) - 1; j >= 0; j-- {
		if i.list[j].M.GetSubjectHeader() == subject {
			return i.list[j]
		}
	}
	return nil
}

// addLMI adds a new Message to the Incident, with the specified LMI.
func (i *Incident) addLMI(lmi string) *Message {
	i.index[lmi] = &Message{LMI: lmi, incident: i}
	i.list = append(i.list, i.index[lmi])
	sort.Slice(i.list, func(a, b int) bool {
		return lmiLess(i.list[a].LMI, i.list[b].LMI)
	})
	return i.index[lmi]
}

// lmiLess returns whether a is less than b, where both are interpreted as
// local message IDs.
func lmiLess(a, b string) bool {
	if a[:3] != b[:3] {
		return a[:3] < b[:3]
	}
	if len(a) != len(b) {
		return len(a) < len(b)
	}
	return a < b
}
